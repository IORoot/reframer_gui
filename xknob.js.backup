'use strict';

if (!window.XKnob) {
	(function() {

		// Convenience functions to sanitize numbers.
		var float_or_default = function(x, def) {
			x = parseFloat(x);
			return isNaN(x) ? def : x;
		};
		var int_or_default = function(x, def) {
			x = parseInt(x, 10);
			return isNaN(x) ? def : x;
		};

		////////////////////
		// Global internal variables for UI handling.

		// A XKnob element if one is being dragged right now.
		//
		// Limitation: only one can be changed at the same time.
		//
		// This limitation is not a problem on mouse-driven interfaces, as
		// there is only a single mouse (well, on most systems anyway).
		//
		// For multi-touch interfaces, this code should be rewritten to support
		// multiple knobs being changed at the same time.
		var xknob_being_dragged = null;

		// The mouse (or touch) angle from the last event. Used to calculate
		// the direction (CW or CCW).
		var xknob_drag_previous_angle = null;

		// The (proposed, before applying min/max/divisions) value from the
		// last event.
		var xknob_drag_previous_value = null;

		// The initial value upon starting to drag the knob. Used to decide if
		// 'change' event should be fired.
		var xknob_drag_initial_value = null;

		////////////////////
		// Event handling functions.

		var add_listeners_to_document = function(elem) {
			if (elem instanceof HTMLElement) {
				elem = elem.ownerDocument;
			}
			// Duplicate event listeners are discarded.
			elem.addEventListener('mouseup', stop_dragging);
			elem.addEventListener('mousemove', drag_rotate);
			elem.addEventListener('touchend', stop_dragging);
			elem.addEventListener('touchmove', drag_rotate);
		}
		var remove_listeners_from_document = function(elem) {
			if (elem instanceof HTMLElement) {
				elem = elem.ownerDocument;
			}
			elem.removeEventListener('mouseup', stop_dragging);
			elem.removeEventListener('mousemove', drag_rotate);
			elem.removeEventListener('touchend', stop_dragging);
			elem.removeEventListener('touchmove', drag_rotate);
		}

		// Should be attached to '.knob_gfx'.
		var start_dragging = function(ev) {
			remove_listeners_from_document(ev.target);
			xknob_being_dragged = null;

			// Only handling clicks with the left mouse button.
			if (ev.type === 'mousedown' && ev.button !== 0) {
				return;
			}

			// Finding the XKnob element.
			// ev.target is where the event was originated.
			// ev.currentTarget is where the event listener was attached.
			var shadow_root = ev.currentTarget;
			while (shadow_root && !(shadow_root instanceof ShadowRoot)) {
				shadow_root = shadow_root.parentNode;
			}
			if (!shadow_root) return;
			var xknob = shadow_root.host;
			if (!xknob) return;

			// No reaction if the element is disabled or readonly.
			if (xknob.disabled || xknob.readonly) {
				// Should we call preventDefault/stopPropagation here?
				return;
			}

			// Actual event handling.
			ev.preventDefault();
			ev.stopPropagation();
			xknob_being_dragged = xknob;
			xknob_drag_previous_angle = xknob._get_mouse_angle(ev);
			xknob_drag_previous_value = xknob.value;
			xknob_drag_initial_value = xknob.value;

			add_listeners_to_document(xknob);

			// Giving the element focus to enable keyboard events.
			// We need to do this here because we called preventDefault() and
			// stopPropagation().
			xknob.focus();
		}

		// Should be attached to the document, because this event may happen
		// outside of XKnob.
		var stop_dragging = function(ev) {
			if (!xknob_being_dragged) {
				remove_listeners_from_document(ev.target);
				return;
			}

			if (xknob_being_dragged.disabled || xknob_being_dragged.readonly) {
				remove_listeners_from_document(ev.target);
				return;
			}

			if (xknob_drag_initial_value !== xknob_being_dragged.value) {
				xknob_being_dragged.dispatchEvent(new Event('change', {
					'bubbles': true,
					'cancelable': false
				}));
			}

			remove_listeners_from_document(ev.target);
			xknob_being_dragged = null;
		}

		// Should be attached to the document, because this event may happen
		// outside of XKnob.
		var drag_rotate = function(ev) {
			if (!xknob_being_dragged) {
				remove_listeners_from_document(ev.target);
				return;
			}

			if (xknob_being_dragged.disabled || xknob_being_dragged.readonly) {
				remove_listeners_from_document(ev.target);
				return;
			}

			var new_angle = xknob_being_dragged._get_mouse_angle(ev);
			var old_angle = xknob_drag_previous_angle;
			xknob_drag_previous_angle = new_angle;

			var delta_angle = new_angle - old_angle;
			if (delta_angle < 0) {
				// Because this is a circle
				delta_angle += Math.PI * 2;
			}
			if (delta_angle > Math.PI) {
				// Converting from 0..360 to -180..180.
				delta_angle -= Math.PI * 2;
			}
			console.assert(delta_angle >= -Math.PI && delta_angle <= Math.PI, {'delta_angle': delta_angle, 'old_angle': old_angle, 'new_angle': new_angle});

			var delta_value = delta_angle / Math.PI / 2;
			var new_proposed_value = xknob_drag_previous_value + delta_value;
			var old_actual_value = xknob_being_dragged.value;

			xknob_being_dragged.value = new_proposed_value;

			// The .value setter changes the xknob_drag_previous_value variable
			// (in case the setter was implicitly called by the user).
			// Here, however, we need xknob_drag_previous_value set to this
			// specific value, so we overwrite it.
			xknob_drag_previous_value = new_proposed_value;

			var new_actual_value = xknob_being_dragged.value;
			if (old_actual_value !== new_actual_value) {
				xknob_being_dragged.dispatchEvent(new Event('input', {
					'bubbles': true,
					'cancelable': false
				}));
			}
		}

		// Keyboard support when receiving focus.
		var keypress_handler = function(ev) {
			if (ev.target.disabled) {
				return;
			}

			// Some constants.
			var STEP_SIZE_SMALL = 1;  // For Arrows.
			var STEP_SIZE_MEDIUM = 2;  // For PageUp/PageDown.
			var STEP_SIZE_EXTREME = 3;  // For Home/End.

			var step_size = null;
			var step_direction = null;

			// ev.code and ev.key are new to DOM 3 Events:
			// https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code
			// https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key

			// If I remap my keyboard (e.g. I've remapped Caps Lock to be
			// Escape), then ev.key shows the remapped value (e.g. Escape),
			// while ev.code shows the actual physical key (e.g. Caps Lock).
			//
			// Also, if NumLock is off, numpad keys return their alternate
			// value in ev.key (e.g. ArrowUp), and the actual physical key in
			// ev.code (e.g. Numpad8).
			//
			// For this component, ev.key makes more sense than ev.code, as we
			// are interested in the logical value/action, and not the physical
			// key location.

			switch (ev.key) {
				// The same direction/orientation as <input type="range">.
				case 'Home':
				case 'PageDown':
				case 'ArrowLeft':
				case 'ArrowDown':
					step_direction = -1;
					break;
				case 'End':
				case 'PageUp':
				case 'ArrowRight':
				case 'ArrowUp':
					step_direction = +1;
					break;
				default:
					return;
			}
			switch (ev.key) {
				case 'Home':
				case 'End':
					step_size = STEP_SIZE_EXTREME;
					break;
				case 'PageUp':
				case 'PageDown':
					step_size = STEP_SIZE_MEDIUM;
					break;
				case 'ArrowRight':
				case 'ArrowLeft':
				case 'ArrowDown':
				case 'ArrowUp':
					step_size = STEP_SIZE_SMALL;
					break;
				default:
					return;
			}

			// Sanity check.
			if (step_size === null || step_direction === null) {
				console.error('This should not happen! step_size=' + step_size + ', step_direction=' + step_direction);
				return;
			}

			ev.preventDefault();
			//ev.stopPropagation();

			// Read-only will receive and process the events, but won't change
			// the value.
			if (ev.target.readonly) {
				return;
			}

			var initial_value = ev.target.value;

			if (step_size === STEP_SIZE_EXTREME) {
				if (step_direction < 0) {
					if (ev.target.min !== null) {
						ev.target.value = ev.target.min;
					}
				} else if (step_direction > 0) {
					if (ev.target.max !== null) {
						ev.target.value = ev.target.max;
					}
				}
			} else if (step_size === STEP_SIZE_MEDIUM) {
				var divisions = ev.target.divisions;
				var step = 1.0 / 8;
				// Finding a step amount near 45deg:
				if (divisions >= 2) {
					step = Math.round(step * divisions) / divisions;
					// In case the previous expression evaluated to zero.
					step = Math.max(step, 1.0 / divisions);
				}
				ev.target.value += step * step_direction;
			} else if (step_size === STEP_SIZE_SMALL) {
				var divisions = ev.target.divisions;
				var step = 1.0 / 64;
				if (divisions >= 2) {
					step = 1.0 / divisions;
				}
				ev.target.value += step * step_direction;
			} else {
				console.error('This should not happen! Unknown step_size: ' + step_size);
			}

			if (initial_value !== ev.target.value) {
				ev.target.dispatchEvent(new Event('input', {
					'bubbles': true,
					'cancelable': false
				}));
				ev.target.dispatchEvent(new Event('change', {
					'bubbles': true,
					'cancelable': false
				}));

				// Trying to improve the corner-case of someone dragging the
				// control at same time as using keyboard.
				if (xknob_being_dragged) {
					xknob_drag_initial_value = ev.target.value;
				}
			}
		}

		////////////////////
		// The actual XKnob object.
		class XKnob extends HTMLElement {
			static get observedAttributes() {
				return ['min', 'max', 'step', 'value', 'disabled', 'readonly'];
			}

			constructor() {
				super();
				this.attachShadow({ mode: 'open' });
				this._min = 0;
				this._max = 1;
				this._step = 0.01;
				this._value = 0;
				this._disabled = false;
				this._readonly = false;
				this._dragging = false;
				this._center = 24;
				this._radius = 22;
				this._lastAngle = 0;
				this._rotation = 0;
				this._render();
			}

			connectedCallback() {
				this._upgradeProperty('value');
				this._upgradeProperty('min');
				this._upgradeProperty('max');
				this._upgradeProperty('step');
				this._upgradeProperty('disabled');
				this._upgradeProperty('readonly');
				this._addEventListeners();
				this._update();
						}

			attributeChangedCallback(name, oldValue, newValue) {
				if (oldValue === newValue) return;
				switch (name) {
					case 'min': this._min = parseFloat(newValue); break;
					case 'max': this._max = parseFloat(newValue); break;
					case 'step': this._step = parseFloat(newValue); break;
					case 'value': this.value = parseFloat(newValue); break;
					case 'disabled': this._disabled = newValue !== null; break;
					case 'readonly': this._readonly = newValue !== null; break;
				}
				this._update();
			}

			get value() { return this._value; }
			set value(val) {
				const v = this._clamp(this._stepRound(parseFloat(val)));
				if (v !== this._value) {
					this._value = v;
					this.setAttribute('value', v);
					this._update();
					this.dispatchEvent(new Event('input', { bubbles: true }));
					}
			}
			get min() { return this._min; }
			set min(val) { this._min = parseFloat(val); this.setAttribute('min', val); this._update(); }
			get max() { return this._max; }
			set max(val) { this._max = parseFloat(val); this.setAttribute('max', val); this._update(); }
			get step() { return this._step; }
			set step(val) { this._step = parseFloat(val); this.setAttribute('step', val); this._update(); }
			get disabled() { return this._disabled; }
			set disabled(val) { this._disabled = !!val; this._update(); }
			get readonly() { return this._readonly; }
			set readonly(val) { this._readonly = !!val; this._update(); }

			_upgradeProperty(prop) {
				if (this.hasOwnProperty(prop)) {
					let value = this[prop];
					delete this[prop];
					this[prop] = value;
				}
			}

			_clamp(val) {
				return Math.max(this._min, Math.min(this._max, val));
			}
			_stepRound(val) {
				if (!isFinite(this._step) || this._step <= 0) return val;
				return Math.round((val - this._min) / this._step) * this._step + this._min;
						}

			_render() {
				this.shadowRoot.innerHTML = `
					<style>
						:host { 
							display: inline-block; 
							width: 48px; 
							height: 48px; 
							pointer-events: none;
						}
						svg { 
							width: 100%; 
							height: 100%; 
							display: block; 
							pointer-events: none;
						}
						.knob-bg { 
							transition: fill 0.2s; 
							fill: #e5e5e5;
							stroke: #b0b0b0;
							stroke-width: 1.5;
							filter: drop-shadow(0 2px 6px rgba(0,0,0,0.10));
						}
						.knob-indicator { 
							transition: stroke 0.2s; 
							stroke: #ff6a1a;
							stroke-width: 4;
							stroke-linecap: round;
							filter: drop-shadow(0 0 2px #ff6a1a88);
						}
						.knob-dot { 
							transition: fill 0.2s; 
							fill: #ff6a1a;
							filter: drop-shadow(0 0 4px #ff6a1a88);
						}
						.knob-indicator-group {
							pointer-events: auto;
							cursor: pointer;
						}
					</style>
					<svg viewBox="0 0 48 48">
						<circle class="knob-bg" cx="24" cy="24" r="22"/>
						<g class="knob-indicator-group"></g>
						<circle class="knob-dot" cx="24" cy="24" r="4"/>
					</svg>
				`;
				this._svg = this.shadowRoot.querySelector('svg');
				this._indicatorGroup = this.shadowRoot.querySelector('.knob-indicator-group');
			}

			_addEventListeners() {
				this._svg.addEventListener('mousedown', this._onPointerDown.bind(this));
				this._svg.addEventListener('touchstart', this._onPointerDown.bind(this), { passive: false });
				window.addEventListener('mousemove', this._onPointerMove.bind(this));
				window.addEventListener('touchmove', this._onPointerMove.bind(this), { passive: false });
				window.addEventListener('mouseup', this._onPointerUp.bind(this));
				window.addEventListener('touchend', this._onPointerUp.bind(this));
			}

			_getAngleFromCenter(x, y) {
				const rect = this._svg.getBoundingClientRect();
				const cx = rect.left + rect.width / 2;
				const cy = rect.top + rect.height / 2;
				return Math.atan2(y - cy, x - cx);
			}

			_onPointerDown(e) {
				if (this._disabled || this._readonly) return;
				e.preventDefault();
				this._dragging = true;
				const { clientX, clientY } = e.touches ? e.touches[0] : e;
				this._lastAngle = this._getAngleFromCenter(clientX, clientY);
				this._startValue = this._value;
				this._rotation = 0;
						}

			_onPointerMove(e) {
				if (!this._dragging) return;
				e.preventDefault();
				const { clientX, clientY } = e.touches ? e.touches[0] : e;
				const angle = this._getAngleFromCenter(clientX, clientY);
				let delta = angle - this._lastAngle;
				// Normalize delta to [-PI, PI]
				if (delta > Math.PI) delta -= 2 * Math.PI;
				if (delta < -Math.PI) delta += 2 * Math.PI;
				this._rotation += delta;
				this._lastAngle = angle;
				// Map rotation to value
				const range = this._max - this._min;
				let newValue = this._startValue + (this._rotation / (2 * Math.PI)) * range;
				newValue = this._clamp(this._stepRound(newValue));
				if (newValue !== this._value) {
					this._value = newValue;
					this.setAttribute('value', newValue);
					this._update();
					this.dispatchEvent(new Event('input', { bubbles: true }));
				}
			}

			_onPointerUp(e) {
				if (!this._dragging) return;
				this._dragging = false;
				this.dispatchEvent(new Event('change', { bubbles: true }));
			}

			_update() {
				// Draw indicator arc and line
				if (!this._indicatorGroup) return;
				const angle = ((this._value - this._min) / (this._max - this._min)) * 2 * Math.PI - Math.PI / 2;
				const r = 16;
				const x2 = 24 + r * Math.cos(angle);
				const y2 = 24 + r * Math.sin(angle);
				// Arc (background)
				this._indicatorGroup.innerHTML = `
					<path class="knob-indicator" d="M24,24 L${x2},${y2}"/>
				`;
				// Update disabled/readonly style
				this._svg.style.opacity = this._disabled ? 0.5 : 1;
				this._svg.style.pointerEvents = this._disabled ? 'none' : 'auto';
			}
		}

		customElements.define('x-knob', XKnob);
	})();
}
